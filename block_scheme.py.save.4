,#!/usr/bin/env python
import os
import RPi.GPIO as GPIO
import signal
import subprocess
import sys
import time
import string
import datetime
from time import strftime
from radio_class import Radio
from lcd_class import Lcd
import shutil
import urllib
from lcd_class import Lcd
from xml.dom import minidom
import getpass, poplib
import datetime
import time
mesaj_array = [' ',' ',' ',' ',' ',' ',' ',' ',' ',' ']
msg =""
CITY_ID = '877873' #codul pentru Ploiesti
TEMP_TYPE = 'c' #adica in grade celsius
WEATHER_URL = 'http://xml.weather.yahoo.com/forecastrss?w=' + CITY_ID +' &u=c'
WEATHER_NS = 'http://xml.weather.yahoo.com/ns/rss/1.0'
MENU_SWITCH = 25 #definitia butoanelor
LEFT_SWITCH = 14
RIGHT_SWITCH = 15
UP_SWITCH = 18
DOWN_SWITCH = 17
METEO=0
RADIO=1
#CENTRALA=2
MAIL=2
STATE=METEO #starea in care e sistemul
METEO_time = time.time()
meteo_mesaj = ""
radio_lcd=""
MERGE=0
FLAG=""
durata_mesaj= []
split_mesaj=[]
time_change = 0
i_index=0
nr_iteratii=0
first = 0#pentru debounce
nr_new_msg = 0#numarul de mesaje noi

#merge radioul
lcd = Lcd() #defineste lcd-ul
lcd.init()
GPIO.setmode(GPIO.BCM) # Use BCM GPIO numbers
GPIO.setup(MENU_SWITCH, GPIO.IN)
GPIO.setup(UP_SWITCH, GPIO.IN)
GPIO.setup(DOWN_SWITCH, GPIO.IN)
GPIO.setup(LEFT_SWITCH, GPIO.IN)
GPIO.setup(RIGHT_SWITCH, GPIO.IN)
radiolist = open('radiolist', 'r')
line = radiolist.readline()
radio =[]
RADIO_time=time.time()
settle_time = 0
while line:
	temp = line.split('&')
	radio.append((temp[0], temp[1].strip('\n')))
	line = radiolist.readline()
#aici reconstituie lista de radiouri disponibile

host =""
for i in range (0,len(radio)):
	host = host + " "+str(radio[i][0])
#aici scot playlistul si descrierea posturilor
station = open('station','r')
current = int(station.readline())
#aici incarc statia curenta
warp = len(radio)
radiolist.close()
station.close()

maildump=open('maildump','r')
nxt = 0
prv = 0
str_mail = maildump.read()
for i in range(10):
#    print str_mail	
    nxt = str_mail.find("***", prv)
#    print next	
    mesaj_array[i]=str_mail[prv:nxt-2]
    prv = nxt+5
    #print prv	
    #print mesaj_array[i]
maildump.close



volum = open('volume','r')
vol = int(volum.readline())
volum.close()
#aici incarc setarea de volum

time_stamp = time.time()
time_now = time_stamp
#momentul de start
def exec_cmd(cmd):
	p = os.popen(cmd)
	result = ""
	while p.readline():
	        result = result + p.readline()
    #.rstrip('\n')
	return result
exec_cmd('pkill -9 -f vlc')
exec_cmd ('gpio mode 12 out')
def switch_event_menu(p):
    global STATE
    global radio, time_stamp
    global host, RADIO_time
    global current, warp
    global vol, MERGE
    global radio_lcd, FLAG, settle_time, nr_new_msg
    debounce = time.time()
    if GPIO.input(MENU_SWITCH):
        if STATE ==METEO:
            STATE=RADIO
            settle_time = time.time()
	    if MERGE ==0:
                exec_cmd('su - pi -c "vlc '+host+' -I rc --rc-host 127.0.0.1:4222 --novideo -d && ls"')
                #porneste radioul cu lista de statii
                MERGE = 1
                time.sleep(1)
                #asteptam initializarea vlc-ului
                string = ('echo "gotoitem '+ str(current)+'" | netcat 127.0.0.1 4222 ')
                exec_cmd(string)
                string2 = ('echo "volume ' + str(vol)+ '" |netcat 127.0.0.1 4222 ')
                # volumul curent
                exec_cmd(string2)
                index = 4+warp-current
                text_line2=(str(radio[index-1][1]))
                radio_lcd=("Volum "+str(vol)+"\n"+"1&"+"Statia "+text_line2+"\n"+"1&")

                FLAG = radio_lcd
#		print FLAG
	        RADIO_time=time.time()	
		#aici incarca descrierea statiei
                #lcd.line2(text_line2)            
        elif STATE==RADIO:
#            settle_time = time.time()+6
            while GPIO.input(p):
                   time.sleep(.1)
                   if time.time()>debounce+1:
                        string =  ('echo "shutdown" | netcat 127.0.0.1 4222 ')
                        exec_cmd(string)
                        time.sleep(1)
                        MERGE=0
	   	        STATE=METEO
            	        break	    
	    STATE=MAIL
        elif STATE==MAIL:
            while GPIO.input(p):
                   time.sleep(.1)
                   if time.time()>debounce+1:
			nr_new_msg -=1
			if nr_new_msg ==0:
				STATE= METEO
                        break

            STATE=METEO
                
    #reporneste detectarea butoanelor
    return


def switch_event_up(p):
    global current, warp
    global STATE, vol
    global time_stamp, radio_lcd, FLAG, RADIO_time, settle_time
#    settle_time = time.time()+1
    if STATE ==RADIO:
        while GPIO.input(p):
            exec_cmd ('echo "volume +10"|netcat 127.0.0.1 4222')
            #incrementeaza continuu volumul
            vol = vol +10 #cand termina actualizeaza valoare, o afiseaza si o scrie in fisierul "volume"
            index = 4+warp-current
            text_line2=(str(radio[index-1][1]))
	    radio_lcd=("Volum "+str(vol)+"\n"+"1&"+"Statia "+text_line2+"\n"+"1&")
	#print radio_lcd
            FLAG = radio_lcd
            RADIO_time=time.time()
            time.sleep(0.2)

            volum = open('volume','w')
            volum.write(str(vol))
            volum.close()
    return
#volume up =10 (cat timp e apasat butonul)


def switch_event_down(p):
    global current, warp
    global STATE, vol
    global time_stamp, radio_lcd, FLAG, RADIO_time, settle_time
 #   settle_time = time.time()+1
    if STATE ==RADIO:
        while GPIO.input(p):
            exec_cmd ('echo "volume -10"|netcat 127.0.0.1 4222')
            vol = vol -10
            index = 4+warp-current
            text_line2=(str(radio[index-1][1]))
            radio_lcd=("Volum "+str(vol)+"\n"+"1&"+"Statia "+text_line2+"\n"+"1&")
           # print radio_lcd
            FLAG = radio_lcd
            RADIO_time=time.time()
            time.sleep(0.2)
        volum = open('volume','w')
        volum.write(str(vol))
        volum.close()
    return
#volume down -10 (cat timp e apasat butonul)

def switch_event_next(p):
    global current, warp
    global STATE
    global time_stamp, radio_lcd, FLAG, RADIO_time, settle_time
    #settle_time = time.time()+5
    debounce = time.time()

    while GPIO.input(p):
           time.sleep(.1)
           if time.time()>debounce+1:
		   p=os.popen('gpio read 12') 		  
		   m=int(p.readline())
		   m=(m+1)%2
		   #print m
	           exec_cmd('gpio write 12 '+str(m))
                  # time.sleep(1)
                   break



    if STATE ==RADIO:
	if time.time()<debounce+0.9:
        	exec_cmd ('echo "next"|netcat 127.0.0.1 4222')
        	temp = current -5
        	current = (temp%warp)+4
        	index = 4+warp-current
        	text_line2=(str(radio[index-1][1]))
        	radio_lcd=("Volum "+str(vol)+"\n"+"1&"+"Statia "+text_line2+"\n"+"1&")
#         print radio_lcd
             
        	FLAG = radio_lcd            
        	RADIO_time=time.time()
#                      aici e descrierea statiei
        	station = open('station','w')
        	station.write(str(current))
        	station.close()#scrie denumirea statiei in fisierul "station"


    return
#next station (cat timp e apasat butonul)

def switch_event_prev(p):
    global current, warp
    global STATE, radio
    global time_stamp, radio_lcd, FLAG, RADIO_time, settle_time
    #settle_time = time.time()+5
    debounce = time.time()

#    while GPIO.input(p):
#           time.sleep(.1)
#           if time.time()>debounce+1:
#                   exec_cmd('gpio write 12 1')
#                   time.sleep(1)
#                   break


    if STATE ==RADIO:
        exec_cmd ('echo "prev"|netcat 127.0.0.1 4222')
        temp = current -3
        current = (temp%warp)+4
        index = 4+warp-current
        text_line2=(str(radio[index-1][1]))
        radio_lcd=("Volum "+str(vol)+"\n"+"1&"+"Statia "+text_line2+"\n"+"1&")
        FLAG = radio_lcd
        RADIO_time=time.time()
        station = open('station','w')
        station.write(str(current))
        station.close()

	

    return
#previous station (cat timp e apasat butonul)

def lcd_split (mesaj):
    global FLAG
    FLAG=0	
    split_mesaj=[]
    durata_mesaj= []
    n=1
    next =0
    prev=0
    while (next != -1):	
#	print next
   	next=mesaj.find("\n", prev)
        split_mesaj.append(mesaj[prev:next])
#	print split_mesaj
        prev=mesaj.find("&", next)
#	print prev
        durata_mesaj.append(mesaj[next+1:prev])
	prev +=1
    	next=mesaj.find("\n", prev)
#    print split_mesaj
#    print durata_mesaj
    for i in range(len(split_mesaj)-1):
	lcd.line1(split_mesaj[i])
	lcd.line2(split_mesaj[i+1])
    	for n in range(20):	
		if FLAG:
		    lcd.line1("")
		    lcd.line2("")
		    break
		else:
		    time.sleep(float(durata_mesaj[i])/20)
		    n+=1	
	
    return
def get_forecast():
    dom = minidom.parse(urllib.urlopen(WEATHER_URL))
    ycondition = dom.getElementsByTagNameNS(WEATHER_NS, 'condition')[0]
    present = ycondition.getAttribute('text')
    temp =  ycondition.getAttribute('temp')
    forecasts = ""
    meteo_mesaj = "Now we have "+ str(temp)+"C" +"\n"+"1&"+ str(present)+"\n"+"1&"
    # \n forteaza sfarsitul afisarii pe linia curenta si 2 e durata de afisare in secunde
    i=0
    meteo_mesaj2="" 
    while i<3:
        node = dom.getElementsByTagNameNS(WEATHER_NS, 'forecast')[i]

        meteo_mesaj2 =meteo_mesaj2+"Meteo " +str(node.getAttribute('date'))+"\n"+"1&" + "Low "+str(node.getAttribute('low'))+" High " +str(node.getAttribute('high'))+"\n"+"1&"+str(node.getAttribute('text'))+"\n"+"1&"

        i+=1
    meteo_mesaj=meteo_mesaj+meteo_mesaj2+"\n"+"1&"
#    print todaysdate
    return meteo_mesaj

def text_stack(txt):
	global time_change
	time_change = time.time()
	#print time_change
        global split_mesaj
        global durata_mesaj
	global i_index
	split_mesaj_old = split_mesaj
	durata_mesaj_old = durata_mesaj
	split_mesaj=[]
	durata_mesaj =[]
        n=1
        next =0
        prev=0
        while (next != -1):
#           print next
            next=txt.find("\n", prev)
            split_mesaj.append(txt[prev:next])
#           print split_mesaj
            prev=txt.find("&", next)
#           print prev
            durata_mesaj.append(txt[next+1:prev])
            prev +=1
            next=txt.find("\n", prev)
#        print split_mesaj
#        print durata_mesaj
#    for i in range(len(split_mesaj)-1):
#        lcd.line1(split_mesaj[i])
#        lcd.line2(split_mesaj[i+1])
#        for n in range(20):
#                if FLAG:
#                    lcd.line1("")
#                    lcd.line2("")
#                    break
#                else:
#                    time.sleep(float(durata_mesaj[i])/20)
#                    n+=1
	i_index=0
	return

def text_change(clock1):
	global time_change, split_mesaj, durata_mesaj, settle_time, i_index, nr_iteratii
#	print i_index, len(split_mesaj)
	if i_index < len(split_mesaj):
		if (clock1-time_change) >= float(durata_mesaj[i_index]):
#			print split_mesaj[i_index], durata_mesaj[i_index]
#			print clock1-time_change
#			print i_index
			time_change = clock1
			lcd.line2(split_mesaj[i_index])
			i_index +=1
			if i_index == len(split_mesaj):
				nr_iteratii +=1
				i_index=0
#	print len(split_mesaj)
#	print split_mesaj[1]
#	print durata_mesaj[0]
#	print settle_time
	return


def switch_event(switch):
	global first
	debounce = time.time()
	if first == 0:
		first=1
		while GPIO.input(switch):
			time.sleep(.1)
			if time.time()>debounce+0.15:
				if switch == MENU_SWITCH:
					switch_event_menu(switch)

				if switch == DOWN_SWITCH:
					switch_event_down(switch)

				if switch == UP_SWITCH:
					switch_event_up(switch)

				if switch ==LEFT_SWITCH:
                                        switch_event_next(switch)

                                if switch == RIGHT_SWITCH:
                                        switch_event_prev(switch)

				first=0
				return 1
		
		first =0
		return -1
	else:
		return -1
def get_mail():
	global FLAG, STATE, mesaj_array, nr_new_msg
#	FLAG=0
        user = 'savusfridge'
        Mailbox = poplib.POP3_SSL('pop.googlemail.com', '995')
        Mailbox.user(user)
        Mailbox.pass_('frigider')
        numMessages = len(Mailbox.list()[1])
        if numMessages != 0:
		nr_new_msg +=1
		STATE=MAIL
                msg=""
                todaysdate = strftime("%b %d %H:%M")
                mesaj = todaysdate + "\n1&"
#               for i in range(numMessages):
                for txt in Mailbox.retr(1)[1]:
#                       f.write(txt+"\n")
                        msg = msg+"\n"+txt


                Mailbox.quit()
#               f.close()

                start = msg.find("Message-ID: ")
                n_f=msg.find("From:", start)
#               n_f=msg.find("From:")
                m_f=msg.find("<", n_f)
                mesaj = mesaj + msg[n_f:m_f]+"\n1&"
                n_s=msg.find("Subject:")
                m_s=msg.find("\n", n_s)
                mesaj = mesaj + msg[n_s:m_s]+"\n1&"

                n_body=msg.find("Content-Type: text/plain;")
                n_body=msg.find("\n", n_body)
                n_encode=msg.find("Content-Transfer-Encoding", n_body)
                if n_encode<n_body+50:
                        if n_encode>0:
                            n_body=n_encode
                n_body=msg.find("\n", n_body)
                m_body=msg.find("--", n_body)
                if m_body==-1:
			ms = msg[n_body:].replace('\n', ' ')
                	ms = ms.replace ('  ', ' ')
                	ms = ms.replace ('  ', ' ')
                	ms = ms.replace ('  ', ' ')
                        mesaj = mesaj+ " Body: " + ms+"\n1&"
                else:
                        ms = msg[n_body:m_body].replace('\n', ' ')
                        ms = ms.replace ('  ', ' ')
                        ms = ms.replace ('  ', ' ')
                        ms = ms.replace ('  ', ' ')
                        mesaj = mesaj+ " Body: " + ms+"\n1&"

                FLAG= mesaj
		#print mesaj
                for i in range (9):
                        mesaj_array[i] = mesaj_array[i+1]
                mesaj_array[9]=mesaj
                maildump = open('maildump', 'w')
                for i in range (10):
         #               maildump = open('maildump', 'w')
                        maildump.write(mesaj_array[i]+"\n *** \n")
                maildump.close



	if STATE==MAIL:

	        maildump=open('maildump','r')
	        nxtt = 0
	        prvv = 0
	        str_mail=maildump.read()
	        for i in range(10):
	               nxtt = str_mail.find("***", prvv)
	               mesaj_array[i]=str_mail[prvv:nxtt-2]
	               prvv = nxtt+5
	               #print mesaj_array[i]
	        maildump.close
#		maildump=open('maildump','r')
#		next = 0
#		prev = 0
#		for i in range(10):
#			next = maildump.read().find("***", prev)
#			mesaj_array[i]=maildump.read()[prev:next]
#			prev = next+3
#			print mesaj_array[i]
#		maildump.close
	return

#GPIO.add_event_detect(MENU_SWITCH, GPIO.RISING, callback=switch_event_menu, bouncetime=500)
#GPIO.add_event_detect(DOWN_SWITCH, GPIO.RISING, callback=switch_event_down, bouncetime=500)
#GPIO.add_event_detect(UP_SWITCH, GPIO.RISING, callback=switch_event_up, bouncetime=500)
#GPIO.add_event_detect(LEFT_SWITCH, GPIO.RISING, callback=switch_event_next, bouncetime=500)
#GPIO.add_event_detect(RIGHT_SWITCH, GPIO.RISING, callback=switch_event_prev, bouncetime=500)

GPIO.add_event_detect(MENU_SWITCH, GPIO.RISING, callback=switch_event)
GPIO.add_event_detect(DOWN_SWITCH, GPIO.RISING, callback=switch_event)
GPIO.add_event_detect(UP_SWITCH, GPIO.RISING, callback=switch_event)
GPIO.add_event_detect(LEFT_SWITCH, GPIO.RISING, callback=switch_event)
GPIO.add_event_detect(RIGHT_SWITCH, GPIO.RISING, callback=switch_event)




#definirea butoanelor si a intreruperilor generate de ele
FLAG=get_forecast()
METEO_time=time.time()
get_mail()
MAIL_time = time.time()
#print get_forecast()
#lcd_split(meteo_lcd)
lcd.init()
lcd_time=0
while True:
    inceput = time.time()
    if STATE==RADIO:
	if inceput-settle_time>=120:
	    STATE=METEO
	    FLAG=get_forecast()	
    if FLAG != "":
        #print FLAG
	text_stack(FLAG) #updateaza textul de afisat

	FLAG=""


    text_change(inceput)#testeaza daca e cazul sa se schime ce-i afisat

#    print str(todaysdate)
#    print str(STATE)
    if (inceput-lcd_time)>=0.5:
#	print "hit"
#	if inceput >= settle_time:
	time_string = strftime("%H:%M:%S")
	lcd.line1(time_string+"  "+str(STATE))
#	time.sleep(.1)
        lcd_time=inceput

#    if STATE==METEO:
    if (inceput - METEO_time)>=900:
        FLAG=get_forecast()
        METEO_time=time.time()

    if (inceput - MAIL_time)>=60:
        get_mail()
        MAIL_time=time.time()

#   if STATE==MAIL:
	
##    print radio_lcd
#    if STATE==RADIO:
#        lcd_split(radio_lcd)
#    print STATE	
#    if (inceput-RADIO_time) >=60:
#       if (inceput - METEO_time)>=60:
#               meteo_lcd=get_forecast()
#               METEO_time=time.time()
#       radio_lcd = radio_lcd+meteo_lcd
#       RADIO_time=time.time()
